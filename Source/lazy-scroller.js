var LazyScroller = new Class({	Implements: [Options, Events],	options: {		scrollOptions:{},		useTopBottom:false	},	initialize: function(prevKeys, nextKeys, items, options){		this.setOptions(options);		this.items=items.sort(this.itemsSorter);		this.currentItemIndex=-1;		this.postScrollInterval=null;		this.scroller=new Fx.Scroll(window, this.options.scrollOptions);		//		if (typeOf(prevKeys)=='string') prevKeys=[prevKeys];		if (typeOf(nextKeys)=='string') nextKeys=[nextKeys];		//		var scs={};		prevKeys.each(function(item) {			scs['LazyScroller-'+item]={				'keys': item,				'handler': this.onPrevKey.bind(this)			};		}, this);		nextKeys.each(function(item) {			scs['LazyScroller-'+item]={				'keys': item,				'handler': this.onNextKey.bind(this)			};		}, this);		Keyboard.manager.addShortcuts(scs);		//		this.storeCurrentItemIndex();		window.addEvent('scroll', this.onScrollEnd.bind(this));	},	itemsSorter: function(a, b) {		return a.getCoordinates().top < b.getCoordinates().top ? -1 : 1;	},	onScrollEnd: function() {		clearTimeout(this.postScrollInterval);		this.postScrollInterval=this.storeCurrentItemIndex.delay(500, this);	},	storeCurrentItemIndex: function() {		var topMin=9999;		this.items.each(function(item, index) {			var topDist=Math.abs(item.getPosition().y-window.getScroll().y);			if (topDist<=topMin) {				topMin=topDist;				this.currentItemIndex=index;			}		}, this);	},	keyEventIsInInput: function(ev) {		return (ev.target.get('tag') == 'input' || ev.target.get('tag') == 'textarea');	},	onPrevKey: function(e) {		this.onKey(e, true);	},	onNextKey: function (e) {		this.onKey(e, false);	},	onKey:function(e, goPrev) {		var ev=new Event(e);		if (this.keyEventIsInInput(ev)) return;		//		var prev=goPrev;		var next=!prev;		if ((this.currentItemIndex==0 && prev) || (this.currentItemIndex==this.items.length-1 && next)) {			if (this.options.useTopBottom) {				this.scroller.cancel();				if (prev) this.scroller.toTop();				else this.scroller.toBottom();				return;			}			this.fireEvent('noscroll', ev.key);			return;		}		//		this.currentItemIndex=Math.max(0, Math.min(this.items.length-1, this.currentItemIndex+(next ? 1 : -1)));		var tg=this.items[this.currentItemIndex];		if (!tg) return;		ev.stop();		//		this.scroller.cancel();		this.scroller.toElement(tg);	}});